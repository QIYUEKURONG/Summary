<!DOCTYPE html>
<html>
<head>
<title>FunctionAndStructAndInterface.md</title>
<meta http-equiv="Content-type" content="text/html;charset=UTF-8">

<style>
/*---------------------------------------------------------------------------------------------
 *  Copyright (c) Microsoft Corporation. All rights reserved.
 *  Licensed under the MIT License. See License.txt in the project root for license information.
 *--------------------------------------------------------------------------------------------*/

body {
	font-family: "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
	font-size: 14px;
	padding: 0 12px;
	line-height: 22px;
	word-wrap: break-word;
}

#code-csp-warning {
	position: fixed;
	top: 0;
	right: 0;
	color: white;
	margin: 16px;
	text-align: center;
	font-size: 12px;
	font-family: sans-serif;
	background-color:#444444;
	cursor: pointer;
	padding: 6px;
	box-shadow: 1px 1px 1px rgba(0,0,0,.25);
}

#code-csp-warning:hover {
	text-decoration: none;
	background-color:#007acc;
	box-shadow: 2px 2px 2px rgba(0,0,0,.25);
}


body.scrollBeyondLastLine {
	margin-bottom: calc(100vh - 22px);
}

body.showEditorSelection .code-line {
	position: relative;
}

body.showEditorSelection .code-active-line:before,
body.showEditorSelection .code-line:hover:before {
	content: "";
	display: block;
	position: absolute;
	top: 0;
	left: -12px;
	height: 100%;
}

body.showEditorSelection li.code-active-line:before,
body.showEditorSelection li.code-line:hover:before {
	left: -30px;
}

.vscode-light.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(0, 0, 0, 0.15);
}

.vscode-light.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(0, 0, 0, 0.40);
}

.vscode-dark.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 255, 255, 0.4);
}

.vscode-dark.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 255, 255, 0.60);
}

.vscode-high-contrast.showEditorSelection .code-active-line:before {
	border-left: 3px solid rgba(255, 160, 0, 0.7);
}

.vscode-high-contrast.showEditorSelection .code-line:hover:before {
	border-left: 3px solid rgba(255, 160, 0, 1);
}

img {
	max-width: 100%;
	max-height: 100%;
}

a {
	color: #4080D0;
	text-decoration: none;
}

a:focus,
input:focus,
select:focus,
textarea:focus {
	outline: 1px solid -webkit-focus-ring-color;
	outline-offset: -1px;
}

hr {
	border: 0;
	height: 2px;
	border-bottom: 2px solid;
}

h1 {
	padding-bottom: 0.3em;
	line-height: 1.2;
	border-bottom-width: 1px;
	border-bottom-style: solid;
}

h1, h2, h3 {
	font-weight: normal;
}

h1 code,
h2 code,
h3 code,
h4 code,
h5 code,
h6 code {
	font-size: inherit;
	line-height: auto;
}

a:hover {
	color: #4080D0;
	text-decoration: underline;
}

table {
	border-collapse: collapse;
}

table > thead > tr > th {
	text-align: left;
	border-bottom: 1px solid;
}

table > thead > tr > th,
table > thead > tr > td,
table > tbody > tr > th,
table > tbody > tr > td {
	padding: 5px 10px;
}

table > tbody > tr + tr > td {
	border-top: 1px solid;
}

blockquote {
	margin: 0 7px 0 5px;
	padding: 0 16px 0 10px;
	border-left: 5px solid;
}

code {
	font-family: Menlo, Monaco, Consolas, "Droid Sans Mono", "Courier New", monospace, "Droid Sans Fallback";
	font-size: 14px;
	line-height: 19px;
}

body.wordWrap pre {
	white-space: pre-wrap;
}

.mac code {
	font-size: 12px;
	line-height: 18px;
}

pre:not(.hljs),
pre.hljs code > div {
	padding: 16px;
	border-radius: 3px;
	overflow: auto;
}

/** Theming */

.vscode-light,
.vscode-light pre code {
	color: rgb(30, 30, 30);
}

.vscode-dark,
.vscode-dark pre code {
	color: #DDD;
}

.vscode-high-contrast,
.vscode-high-contrast pre code {
	color: white;
}

.vscode-light code {
	color: #A31515;
}

.vscode-dark code {
	color: #D7BA7D;
}

.vscode-light pre:not(.hljs),
.vscode-light code > div {
	background-color: rgba(220, 220, 220, 0.4);
}

.vscode-dark pre:not(.hljs),
.vscode-dark code > div {
	background-color: rgba(10, 10, 10, 0.4);
}

.vscode-high-contrast pre:not(.hljs),
.vscode-high-contrast code > div {
	background-color: rgb(0, 0, 0);
}

.vscode-high-contrast h1 {
	border-color: rgb(0, 0, 0);
}

.vscode-light table > thead > tr > th {
	border-color: rgba(0, 0, 0, 0.69);
}

.vscode-dark table > thead > tr > th {
	border-color: rgba(255, 255, 255, 0.69);
}

.vscode-light h1,
.vscode-light hr,
.vscode-light table > tbody > tr + tr > td {
	border-color: rgba(0, 0, 0, 0.18);
}

.vscode-dark h1,
.vscode-dark hr,
.vscode-dark table > tbody > tr + tr > td {
	border-color: rgba(255, 255, 255, 0.18);
}

.vscode-light blockquote,
.vscode-dark blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.vscode-high-contrast blockquote {
	background: transparent;
	border-color: #fff;
}
</style>

<style>
/* Tomorrow Theme */
/* http://jmblog.github.com/color-themes-for-google-code-highlightjs */
/* Original theme - https://github.com/chriskempson/tomorrow-theme */

/* Tomorrow Comment */
.hljs-comment,
.hljs-quote {
	color: #8e908c;
}

/* Tomorrow Red */
.hljs-variable,
.hljs-template-variable,
.hljs-tag,
.hljs-name,
.hljs-selector-id,
.hljs-selector-class,
.hljs-regexp,
.hljs-deletion {
	color: #c82829;
}

/* Tomorrow Orange */
.hljs-number,
.hljs-built_in,
.hljs-builtin-name,
.hljs-literal,
.hljs-type,
.hljs-params,
.hljs-meta,
.hljs-link {
	color: #f5871f;
}

/* Tomorrow Yellow */
.hljs-attribute {
	color: #eab700;
}

/* Tomorrow Green */
.hljs-string,
.hljs-symbol,
.hljs-bullet,
.hljs-addition {
	color: #718c00;
}

/* Tomorrow Blue */
.hljs-title,
.hljs-section {
	color: #4271ae;
}

/* Tomorrow Purple */
.hljs-keyword,
.hljs-selector-tag {
	color: #8959a8;
}

.hljs {
	display: block;
	overflow-x: auto;
	color: #4d4d4c;
	padding: 0.5em;
}

.hljs-emphasis {
	font-style: italic;
}

.hljs-strong {
	font-weight: bold;
}
</style>

<style>
/*
 * Markdown PDF CSS
 */

 body {
	font-family:  "Meiryo", "Segoe WPC", "Segoe UI", "SFUIText-Light", "HelveticaNeue-Light", sans-serif, "Droid Sans Fallback";
}

pre {
	background-color: #f8f8f8;
	border: 1px solid #cccccc;
	border-radius: 3px;
	overflow-x: auto;
	white-space: pre-wrap;
	overflow-wrap: break-word;
}

pre:not(.hljs) {
	padding: 23px;
	line-height: 19px;
}

blockquote {
	background: rgba(127, 127, 127, 0.1);
	border-color: rgba(0, 122, 204, 0.5);
}

.emoji {
	height: 1.4em;
}

/* for inline code */
:not(pre):not(.hljs) > code {
	color: #C9AE75; /* Change the old color so it seems less like an error */
	font-size: inherit;
}

/* Page Break : use <div class="page"/> to insert page break
-------------------------------------------------------- */
.page {
	page-break-after: always;
}

</style>

</head>
<body>
<h1 id="%E5%87%BD%E6%95%B0%E7%BB%93%E6%9E%84%E4%BD%93%E5%92%8C%E6%8E%A5%E5%8F%A3">函数,结构体和接口</h1>
<p>函数基本组成包括：关键字func、函数名、参数列表、返回值、函数体和返回语句
Go 语言不支持继承，Go 语言只支持组合。
Go 语言的中结构体struct与 C++、JAVA 中的类class相似，但 Go 放弃了传统面向对象的诸多特性，只保留了组合</p>
<h2 id="%E5%87%BD%E6%95%B0">函数</h2>
<p>例子：</p>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> Add
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a,b <span class="hljs-keyword">int</span>)</span><span class="hljs-params">(num <span class="hljs-keyword">int</span>，err error)</span></span>{
    <span class="hljs-keyword">return</span> a+b,<span class="hljs-literal">nil</span>
}
</div></code></pre>
<h3 id="%E5%87%BD%E6%95%B0%E7%9A%84%E8%BF%94%E5%9B%9E%E5%80%BC%E5%8F%AF%E4%BB%A5%E6%9C%89%E5%A4%9A%E4%B8%AA%E8%BF%94%E5%9B%9E%E5%80%BC">函数的返回值(可以有多个返回值)</h3>
<p>在Go语言中，函数的返回值可以是多个的，一般包里面的函数都定义了第二个参数那就是error
我们在定义变量的时候可以在多定义一个err
例子：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divide</span> <span class="hljs-params">(a <span class="hljs-keyword">int</span>, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(num <span class="hljs-keyword">int</span>, err error)</span></span>{ <span class="hljs-comment">//定义两个返回值  （先是func，第二是函数名字。参数列表。返回值）</span>
    <span class="hljs-keyword">if</span> b == <span class="hljs-number">0</span> {
        err := errors.New(<span class="hljs-string">"被除数不能为零！"</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>,err
    }
    <span class="hljs-keyword">return</span> a / b, <span class="hljs-literal">nil</span>   <span class="hljs-comment">//支持多个返回值</span>
}
</div></code></pre>
<h3 id="%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0">匿名函数</h3>
<p>例子：</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span>{
 PROCESS
}()
</div></code></pre>
<p>这就是个匿名函数的例子，在这个函数里面没有函数名，参数和返回值</p>
<h2 id="%E7%BB%93%E6%9E%84%E4%BD%93">结构体</h2>
<p>形式就是</p>
<pre class="hljs"><code><div><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span>{
 name <span class="hljs-keyword">string</span>
 age <span class="hljs-keyword">uint</span>
}
</div></code></pre>
<h3 id="%E5%88%9D%E5%A7%8B%E5%8C%96%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1">初始化一个对象</h3>
<p>man := new(person)
man := &amp;person{}
man := &amp;person{&quot;Tom&quot;, 18}
man := &amp;person{name: &quot;Tom&quot;, age: 18}</p>
<h3 id="%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E6%96%B9%E6%B3%95">结构体的方法</h3>
<p>方法是作用在自定义类型上的一类特殊函数，该值可能是以指针或者复制值的形式传递
例如</p>
<pre class="hljs"><code><div><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(per *person)</span> <span class="hljs-title">SetAge</span><span class="hljs-params">(ages <span class="hljs-keyword">uint</span>)</span> <span class="hljs-title">bool</span></span>{
     *per.age=ages
     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(per person)</span> <span class="hljs-title">SetAge</span><span class="hljs-params">(ages <span class="hljs-keyword">uint</span>)</span> <span class="hljs-title">bool</span></span>{
     per.age=ages
     <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>
}
</div></code></pre>
<p>值和指针的区别
1：一个指向自定义类型的值的指针，它的方法集由该类型定义的所有方法组成，无论这些方法接受的是    一个值还是一个指针。如果在指针上调用一个接受值的方法，Go 语言会聪明地将该指针解引用。
一个自定义类型值的方法集合则由该类型定义的接收者为值类型的方法组成，但是不包括那些接收者类型为指针的方法。
2：相对于值的话，你在函数里面赋值在出函数之后就会结束。而相对于指针的话，它给与的是那个变量的地址，对地址里面的数值进行了改变。</p>
<h3 id="%E7%BB%93%E6%9E%84%E4%BD%93%E7%9A%84%E7%BB%84%E5%90%88">结构体的组合</h3>
<p>例子</p>
<pre class="hljs"><code><div><span class="hljs-keyword">package</span> main
<span class="hljs-keyword">import</span> (
<span class="hljs-string">"fmt"</span>
)
<span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> {
name  <span class="hljs-keyword">string</span>
world <span class="hljs-keyword">string</span>
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p person)</span> <span class="hljs-title">setname</span><span class="hljs-params">(realname <span class="hljs-keyword">string</span>)</span></span> {
p.name = realname
fmt.Println(<span class="hljs-string">"the person name is"</span>, p.name)
}
<span class="hljs-keyword">type</span> chinese <span class="hljs-keyword">struct</span> {
person
pro <span class="hljs-keyword">string</span>
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *chinese)</span> <span class="hljs-title">setname</span><span class="hljs-params">(realname <span class="hljs-keyword">string</span>)</span></span> {
c.person.name = realname
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *chinese)</span> <span class="hljs-title">setpro</span><span class="hljs-params">(realpro <span class="hljs-keyword">string</span>)</span></span> {
c.pro = realpro
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c chinese)</span> <span class="hljs-title">display</span><span class="hljs-params">()</span></span> {
fmt.Println(<span class="hljs-string">"name  and pro"</span>, c.person.name, c.pro)
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
x := chinese{}
x.setname(<span class="hljs-string">"jwuenjie"</span>)
x.setpro(<span class="hljs-string">"shanxi"</span>)
x.display()
}
</div></code></pre>
<h2 id="%E6%8E%A5%E5%8F%A3interface">接口(interface)</h2>
<p>接口的作用:
接口是一组方法签名。当一个类型为接口中的所有方法提供定义时，它被称为实现该接口。
接口就是可以接受多种类型的一个窗口。</p>
<p>例子:</p>
<pre class="hljs"><code><div><span class="hljs-keyword">type</span> Shape <span class="hljs-keyword">interface</span> {
area() <span class="hljs-keyword">float64</span>
}
<span class="hljs-keyword">type</span> circue <span class="hljs-keyword">struct</span> {
rad <span class="hljs-keyword">float64</span>
}
<span class="hljs-keyword">type</span> squ <span class="hljs-keyword">struct</span> {
x, y <span class="hljs-keyword">float64</span>
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(cir circue)</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-title">float64</span></span> {
<span class="hljs-keyword">return</span> <span class="hljs-number">3.14</span> * cir.rad * cir.rad
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s squ)</span> <span class="hljs-title">area</span><span class="hljs-params">()</span> <span class="hljs-title">float64</span></span> {
<span class="hljs-keyword">return</span> s.x * s.y
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">fun</span><span class="hljs-params">(shape Shape)</span> <span class="hljs-title">float64</span></span> {
<span class="hljs-keyword">return</span> shape.area()
}
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
<span class="hljs-comment">/* cir := circue{5.5}
squ := squ{1.2, 2.4}
fmt.Println(fun(cir))
fmt.Println(fun(squ)) */</span>
cir := circue{<span class="hljs-number">5.5</span>}
squ := squ{<span class="hljs-number">1.2</span>, <span class="hljs-number">2.4</span>}
<span class="hljs-keyword">var</span> s Shape
s = cir
fmt.Println(s.area())
s = squ
fmt.Println(s.area())
}
</div></code></pre>
<h3 id="%E5%B5%8C%E5%A5%97%E7%9A%84interface">嵌套的interface</h3>
<pre class="hljs"><code><div><span class="hljs-keyword">type</span> Interface1 <span class="hljs-keyword">interface</span> {
    Send()
    Receive()
}

<span class="hljs-keyword">type</span> Interface2 <span class="hljs-keyword">interface</span> {
    Interface1
    Close()
}
</div></code></pre>

</body>
</html>
